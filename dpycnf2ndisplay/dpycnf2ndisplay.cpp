// <copyright file="dpycnf2ndisplay.cpp" company="Visualisierungsinstitut der Universität Stuttgart">
// Copyright © 2025 Visualisierungsinstitut der Universität Stuttgart.
// Licensed under the MIT licence. See LICENCE file for details.
// </copyright>
// <author>Christoph Müller</author>

#include <cassert>
#include <fstream>
#include <iostream>
#include <iterator>
#include <stdexcept>
#include <string>
#include <type_traits>
#include <vector>

#include <nlohmann/json.hpp>

#include <visus/vvand_config/ndisplay_builder.h>


template<class TIterator> TIterator find_switch(
        const TIterator begin,
        const TIterator end,
        const std::string& name) {
    for (auto it = begin; it != end; ++it) {
        if (*it == name) {
            return it;
        }
    }
    return end;
}


template <class TIterator> TIterator find_argument(
        const TIterator begin,
        const TIterator end,
        const std::string& name) {
    auto retval = find_switch(begin, end, name);
    if (retval != end) {
        ++retval;
    }
    return retval;
}


/// <summary>
/// Entry point of the application.
/// </summary>
/// <param name="argc"></param>
/// <param name="argv"></param>
/// <returns></returns>
int main(const int argc, const char **argv) {
    typedef visus::vvand_config::ndisplay_builder<char> builder_type;
    typedef visus::vvand_config::display_configuration<char> config_type;
    typedef std::string string_type;

    try {
        builder_type builder;
        string_type input;
        string_type output;

        {
            auto end = argv + argc;
            auto it = find_argument(argv, end, "/addresses");
            if (it != end) {
                std::ifstream file(*it);
                nlohmann::json addresses;
                file >> addresses;
                builder.add_ip_addresses(addresses);
            }
        }

        {
            auto end = argv + argc;
            auto it = find_argument(argv, end, "/description");
            if (it != end) {
                builder.with_description(*it);
            } else {
                std::string desc = "Generated by ";
                for (int i = 0; i < argc; ++i) {
                    if (i > 0) {
                        desc += ' ';
                    }
                    desc += argv[i];
                }
                builder.with_description(desc);
            }
        }


        {
            auto end = argv + argc;
            auto it = find_argument(argv, end, "/headnode");
            if (it == end) {
                builder.controlled_by("localhost");

            } else {
                const std::string head_node = *it;
                builder.controlled_by(head_node);

                if ((++it != end) && (**it != '/')) {
                    builder.add_ip_address(head_node, *it);
                }
            }
        }

        {
            auto end = argv + argc;
            auto it = find_argument(argv, end, "/height");
            if (it != end) {
                builder.with_physical_height(std::stof(*it));
            }
        }

        {
            auto end = argv + argc;
            auto it = find_argument(argv, end, "/ipd");
            if (it != end) {
                builder.with_ipd(std::stof(*it));
            }
        }

        {
            auto end = argv + argc;
            auto it = find_argument(argv, end, "/input");
            if (it == end) {
                throw std::runtime_error("The /input argument is missing.");
            }
            input = *it;
        }

        {
            auto end = argv + argc;
            auto it = find_argument(argv, end, "/output");
            if (it != end) {
                output = *it;
            }
        }

        {
            auto end = argv + argc;
            auto it = find_argument(argv, end, "/preview");
            if (it != end) {
                builder.with_preview_width(std::stoi(*it));
            }
        }

        {
            auto end = argv + argc;
            auto it = find_argument(argv, end, "/width");
            if (it != end) {
                builder.with_physical_width(std::stof(*it));
            }
        }

        const auto config = config_type::load(input);
        const auto ndisplay = builder.build(config);

        if (output.empty()) {
            std::cout << std::setw(4) << ndisplay << std::endl;
        } else {
            std::ofstream file(output, std::ios::trunc);
            file << std::setw(4) << ndisplay << std::endl;
        }

        return 0;

    } catch (std::exception e) {
        std::cerr << e.what() << std::endl;
        return -1;
    }
}
